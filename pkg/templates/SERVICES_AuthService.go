package templates

const SERVICES_AuthServiceTemplate = `
/* Generated by egg v0.0.1 */

package services

import (
	"context"
	"fmt"
	"time"

	"{{.Namespace}}/cmd/configuration"
	"{{.Namespace}}/internal/repository"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

// CustomJwt represents a JWT token with user-specific information.
type CustomJwt struct {
	UserId               uuid.UUID ` + "`" +`json:"user_id"` + "`" +`
	User				 string   ` + "`" +`json:"user"` + "`" +`
	IsAdmin              bool      ` + "`" +`json:"is_admin"` + "`" +`
	ProfilePic           string   ` + "`" +`json:"profile_pic"` + "`" +`
	jwt.RegisteredClaims ` + "`" +`json:"claims"` + "`" +`
}

// AuthService provides authentication services, including creating and checking tokens.
type AuthService struct {
	ctx    context.Context
	conn   *pgxpool.Pool
	config *configuration.Configuration
}

// newExpiration returns the current time plus 72 hours.
func newExpiration() time.Time {
	return time.Now().Add(time.Hour * 72)
}

// jwtFromUser creates a JWT token from a user object.
//
// This function creates a new JWT token with the user's ID, profile picture URL,
// and an expiration time set to 72 hours in the future. The token is signed with
// the server's secret key.
func jwtFromUser(user *repository.User) *CustomJwt {
	return &CustomJwt{
		UserId: user.ID,
		ProfilePic: *user.ProfilePicUrl,
		User: user.Username,
		IsAdmin: user.Admin,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(newExpiration()),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			ID: user.ID.String(),
			Subject: user.ID.String(),
		},
	}
}

// CreateAuthService creates a new instance of AuthService.
//
// This function takes the context, PostgreSQL connection, and configuration as
// arguments and returns a new AuthService instance.
func CreateAuthService(ctx context.Context, pgPool *pgxpool.Pool, config *configuration.Configuration) *AuthService {
	return &AuthService{ctx, pgPool, config}
}

// Create creates a new token for a user.
//
// This function takes a user object and returns the created token as a string
// along with an error. If an error occurs during the creation of the token,
// the error is returned instead of the token.
func (a *AuthService) Create(user *repository.User) (*string, error) {
	jwttoken := jwtFromUser(user)
	tx, err := a.conn.Begin(a.ctx)
	if err != nil {
		return nil, err
	}

	defer tx.Rollback(a.ctx)
	expiration := jwttoken.ExpiresAt

	// Create token with claims
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwttoken)
	// Sign it with the server JWT_TOKEN
	t, err := token.SignedString([]byte(a.config.Server.JWT))
	if err != nil {
		return nil, err
	}

	params := repository.CreateTokenParams{
		UserID:             user.ID,
		ExpirationDatetime: &expiration.Time,
		Token:              &t,
	}
	repo := repository.New(tx)
	row, err := repo.CreateToken(a.ctx, params)
	if err != nil {
		return nil, err
	}

	tx.Commit(a.ctx)

	return row.Token, nil
}

// CheckToken checks if a given token is valid.
//
// This function takes a token string and returns an error if the token is not
// found in the database. If the token is found but its expiration time has passed,
// an error is also returned.
func (a *AuthService) CheckToken(token string) error {
	tx, err := a.conn.Begin(a.ctx)
	if err != nil {
		return err
	}

	defer tx.Rollback(a.ctx)
	repo := repository.New(tx)
	_, err = repo.FindTokenByToken(a.ctx, &token)
	if err != nil {
		return err
	}
	tx.Commit(a.ctx)


	// check if token is expired
	claims := &CustomJwt{}
	_, err = jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) {
		return []byte(a.config.Server.JWT), nil
	})
	if err != nil {
		return err
	}
	if claims.ExpiresAt.Before(time.Now()) {
		return err
	}
	return nil
}

// Update updates an existing token for a user.
//
// This function takes a user object and returns the updated token as a string
// along with an error. If an error occurs during the update of the token,
// the error is returned instead of the token.
func (a *AuthService) Update(user repository.User) (*string, error) {
	jwttoken := jwtFromUser(&user)
	tx, err := a.conn.Begin(a.ctx)
	if err != nil {
		fmt.Printf("[ERROR] AuthService.Update{ a.conn.Begin } -> Error beginning transaction: %v", err)
		return nil, err
	}

	defer tx.Rollback(a.ctx)
	expiration := jwttoken.ExpiresAt

	// Create token with claims
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwttoken)
	// Sign it with the server JWT_TOKEN
	t, err := token.SignedString([]byte(a.config.Server.JWT))
	if err != nil {
		fmt.Printf("[ERROR] AuthService.Update{ token.SignedString } -> Error signing token: %v", err)
		return nil, err
	}

	fmt.Printf("[INFO] AuthService.Update{ token.SignedString } -> Token: %v TokenLength: %d", t, len(t))
	params := repository.UpdateTokenByUserIdParams{
		UserID:             user.ID,
		ExpirationDatetime: &expiration.Time,
		Token:              &t,
	}
	repo := repository.New(tx)
	err = repo.UpdateTokenByUserId(a.ctx, params)
	if err != nil {
		fmt.Printf("[ERROR] AuthService.Update{ repo.UpdateTokenByUserId } -> Error updating token: %v", err)
		return nil, err
	}
	tx.Commit(a.ctx)
	return &t, nil
}
`
