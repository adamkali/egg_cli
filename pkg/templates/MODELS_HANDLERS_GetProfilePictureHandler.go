package templates

const MODELS_HANDLERS_GetProfilePictureHandlerTemplate = `
/* Generated by egg v0.0.1 */

package handlers

import (
	"fmt"
	"time"

	"{{.Namespace}}/models/responses"
	"{{.Namespace}}/services"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/redis/go-redis/v9"
)

type GetProfilePictureHandler struct {
	UserID                      uuid.UUID
	Context                     echo.Context
	ProfilePictureName          string
	PresignedUserProfilePicture string
	UpdateRedis                 bool			// This will tell the handler to update the redis cache if the profile picture needs to be updated
	Error                       error
	Code                        int
	Locked                      bool
}

func NewGetProfilPictureHandler(ctx echo.Context) *GetProfilePictureHandler {
	return &GetProfilePictureHandler{
		Context: ctx,
		Locked:  false,
		Error:   nil,
		Code:    200,
	}
}

func (h *GetProfilePictureHandler) Lock(code int) *GetProfilePictureHandler {
	h.Locked = true
	h.Code = code
	return h
}

func (h *GetProfilePictureHandler) Handle(fun any) *GetProfilePictureHandler {
	var code int
	if !h.Locked {
		switch handle := fun.(type) {
		case func(token string) error:
			jwt_token := h.Context.Get("user").(*jwt.Token)
			claims := jwt_token.Claims.(*services.CustomJwt)
			h.UserID = claims.UserId
			h.Error = handle(jwt_token.Raw)
			code = 401
			h.ProfilePictureName = claims.ProfilePic
			break
		case func(uploaderID uuid.UUID, uploadName string) (string, error):
			// check if the PresignedUserProfilePicture exists yet in the handler 
			if h.PresignedUserProfilePicture != "" {
				fmt.Printf("[DEBUG] Cached GetProfilePictureHandler.Handle{ h.UserID } Success\n", )
				h.Error = nil
				h.UpdateRedis = false
				break // basically we say that the we have the url from cache and we can return
			}
			fmt.Printf("[DEBUG] GetProfilePictureHandler.Handle{ Must be updated: h.UserID / h.ProfilePictureName: %s / %s }\n", h.UserID.String(), h.ProfilePictureName)
			h.PresignedUserProfilePicture, h.Error = handle(h.UserID, h.ProfilePictureName)
			h.UpdateRedis = true
			code = 500
			break
		// IRedisService GetWithExpiration
		case func(key string) (string, error):
			// check if the PresignedUserProfilePicture exists in redis
			fmt.Printf("[DEBUG] GetProfilePictureHandler.Handle{ h.UserID / h.PresignedUserProfilePicture: %s/%s }\n", h.UserID.String(), h.ProfilePictureName)
			h.PresignedUserProfilePicture, h.Error = handle(h.UserID.String() + "/" + h.ProfilePictureName)
			// dont worry
			if h.Error == redis.Nil {
				h.UpdateRedis = true
				h.PresignedUserProfilePicture = ""
				h.Error = nil
			} else {
				h.UpdateRedis = false	
				code = 500
			}
			break
		case func(key string, value string, expiration time.Duration) error:
			if !h.UpdateRedis {
				h.Error = nil
				break
			}
			h.Error = handle(h.UserID.String() + "/" + h.ProfilePictureName, h.PresignedUserProfilePicture, time.Hour*24)
			code = 500
			break
		default:
			fmt.Printf("Type assertion failed for type: %T\n", fun)
			code = 600
			h.Error = echo.NewHTTPError(code, "Misaligned handler on the server")
			break
		}
		if h.Error != nil {
			return h.Lock(code)
		}
	}
	return h
}

func (h *GetProfilePictureHandler) JSON() error {
	var code int
	var message string
	if h.Locked && h.Error != nil {
		code = h.Code
		if code == 600 {
			message = "Misaligend handler on the server"
		} else {
			message = h.Error.Error()
		}
	} else if code == 200 {
		message = "OK"
	}
	return h.Context.JSON(code, responses.StringResponse{
		Message: message,
		Success: !h.Locked,
		Data:    &h.PresignedUserProfilePicture,
	})

}
`
