package templates

const SERVICES_UserServiceTemplate = `
/* Generated by egg v0.0.1 */

package services

import (
	"context"
	"errors"

	"{{.Namespace}}/internal/repository"
	"{{.Namespace}}/models/requests"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"golang.org/x/crypto/bcrypt"
)

func hashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), 12)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}

func verifyPassword(storedHash, providedPassword string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(providedPassword))
	if err != nil {
		return false
	}
	return true
}

type UserService struct {
	ctx  context.Context
	pool *pgxpool.Pool
}


// Returns a refrence to a new UserService to be used in the controller
func CreateUserService(ctx context.Context, pool *pgxpool.Pool) *UserService {
	return &UserService{ctx, pool }
}

// Creates a new user
//
// params: *requests.NewUserRequest
// returns: (*repository.User, error)
//
// This function takes a NewUserRequest object and returns a User object.
// Both the username and email must be unique. If not an error is returned.
func (UserService *UserService) Create(params *requests.NewUserRequest) (*repository.User, error) {
	BCryptHash, err := hashPassword(params.Password)
	if err != nil {
		return nil, err
	}
	if params.IsAdmin {
		return UserService.addNewUserAdmin(repository.CreateUserAdminParams{
			BCryptHash: BCryptHash,
			Username:   params.Username,
			Email:      params.Email,
		})
	} else {
		return UserService.addNewUser(repository.CreateUserParams{
			BCryptHash: BCryptHash,
			Username:   params.Username,
			Email:      params.Email,
		})
	}
}

func (UserService *UserService) addNewUser(
	params repository.CreateUserParams,
) (*repository.User, error) {
	var user repository.User
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(UserService.ctx)
	repo := repository.New(tx)
	user, err = repo.CreateUser(UserService.ctx, params)
	if err != nil {
		return nil, err
	}
	tx.Commit(UserService.ctx)
	return &user, nil
}

func (UserService *UserService) addNewUserAdmin(
	params repository.CreateUserAdminParams,
) (*repository.User, error) {
	var user repository.User
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(UserService.ctx)
	repo := repository.New(tx)
	user, err = repo.CreateUserAdmin(UserService.ctx, params)
	if err != nil {
		return nil, err
	}
	tx.Commit(UserService.ctx)
	return &user, nil
}

// Login a user
//
// params: *requests.LoginRequest
// returns: (*repository.User, error)
//
// This function takes a requests.LoginRequest object and returns a repository.User object.
// This can be used with either a username or email address to log in a user.
// 
// If the user is not found, an error is returned.
// If the password is incorrect, an error is returned.
func (UserService *UserService) Login(params *requests.LoginRequest) (*repository.User, error) {
	var user repository.User
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(UserService.ctx)
	var BCryptHash string
	repo := repository.New(tx)
	if params.Email != "" {
		BCryptHash, err = repo.FindBCryptHashByEmail(UserService.ctx, params.Email)
		if err != nil {
			return nil, err
		}
		if verifyPassword(BCryptHash, params.Password) {
			user, err = repo.FindUserByEmail(UserService.ctx, params.Email)
			if err != nil {
				return nil, err
			}
		} else {
			return nil, errors.New("Could not verify password")
		}
	} else if params.Username != "" {
		BCryptHash, err = repo.FindBCryptHashByUsername(UserService.ctx, params.Username)
		if err != nil {
			return nil, err
		}
		if verifyPassword(BCryptHash, params.Password) {
			user, err = repo.FindUserByUsername(UserService.ctx, params.Username)
			if err != nil {
				return nil, err
			}
		} else {
			return nil, errors.New("Could not verify password")
		}
	}
	tx.Commit(UserService.ctx)
	return &user, nil
}

// Removes a user by id
//
// params: uuid.UUID
// returns: error
//
// This function takes a uuid.UUID object and returns an error if the user does not exist.
// 
// If the user does not exist, an error is returned.
// If the user is not deleted, an error is returned.
func (UserService *UserService) Remove(user_id uuid.UUID) error {
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(UserService.ctx)
	repo := repository.New(tx)
	if err := repo.DeleteUserByID(UserService.ctx, user_id); err != nil {
		return err
	}
	tx.Commit(UserService.ctx)
	return nil
}

// Get a user by id
//
// params: uuid.UUID
// returns: (*repository.User, error)
//
// This function takes a uuid.UUID object and returns a repository.User object.
// If the user does not exist, an error is returned.
func (UserService *UserService) Get(user_id uuid.UUID) (*repository.User, error) {
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(UserService.ctx)
	var user repository.User
	repo := repository.New(tx)
	if user, err = repo.FindUserByID(UserService.ctx, user_id); err != nil {
		return nil, err
	}
	tx.Commit(UserService.ctx)
	return &user, nil
}

// Get all users
//
// returns: ([]repository.User, error)
//
// This function returns a slice of repository.User objects.
// If there are no users, an error is returned.
//
// If there is an error on the database side, an error is returned.
// 
// [WARN] Should only be used for debugging.
func (UserService *UserService) GetAll() ([]repository.User, error) {
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(UserService.ctx)
	var users []repository.User
	repo := repository.New(tx)
	if users, err = repo.FindUsers(UserService.ctx); err != nil {
		return nil, err
	}
	tx.Commit(UserService.ctx)
	return users, nil
}

// Update a user by id
//
// params:
//    user_id: uuid.UUID,
//    profile_name: string
// returns: (*repository.User, error)
//
// This function takes a uuid.UUID object and a string object and returns a repository.User object.
// If the user does not exist, an error is returned.
func (UserService *UserService) Update(user_id uuid.UUID, profile_name string) (*repository.User, error) {
	tx, err := UserService.pool.Begin(UserService.ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(UserService.ctx)
	repo := repository.New(tx)
	var user repository.User
	if err = repo.UpdateUserProfile(
		UserService.ctx,
		repository.UpdateUserProfileParams{
			ProfilePicUrl: &profile_name,
			ID:            user_id,
		},
	); err != nil {
		return nil, err
	}
	user, err = repo.FindUserByID(UserService.ctx, user_id)
	if err != nil {
		return nil, err
	}
	tx.Commit(UserService.ctx)
	return &user, nil
}
`
